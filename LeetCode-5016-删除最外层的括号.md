## LeetCode-5016-删除最外层的括号

### 1. 解题：

删除最外层的括号

有效括号字符串为空 `("")`、`"(" + A + ")"` 或 `A + B`，其中 `A` 和 `B` 都是有效的括号字符串，`+` 代表字符串的连接。例如，`""`，`"()"`，`"(())()"` 和 `"(()(()))"` 都是有效的括号字符串。

如果有效字符串 `S` 非空，且不存在将其拆分为 `S = A+B` 的方法，我们称其为**原语（primitive）**，其中 `A` 和 `B` 都是非空有效括号字符串。

给出一个非空有效字符串 `S`，考虑将其进行原语化分解，使得：`S = P_1 + P_2 + ... + P_k`，其中 `P_i` 是有效括号字符串原语。

对 `S` 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 `S` 。

**示例 1：**

```
输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

**示例 2：**

```
输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```

**示例 3：**

```
输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。 
```

**提示：**

1. `S.length <= 10000`
2. `S[i]` 为 `"("` 或 `")"`
3. `S` 是一个有效括号字符串

### 2. 解题：

这个题实际上是括号匹配问题的变形。

首先我们知道`S`是一个有效括号字符串。但我们用括号匹配问题来处理：

用`Stack`在存放`(`，用`StringBuilder`来存放解集。

当遇到`(`时，压栈并放入`StringBuilder`，但是如果栈为空，说明是`外（`，不放入`StringBuilder`。

当遇到`)`时，弹栈并放入`StringBuilder`，但是如果栈大小为１，说明是`外）`，不放入`StringBuilder`。

#### 代码：

```java
class Solution {
	public String removeOuterParentheses(String S) {
        if (S == null || S.length() <2)
            return null;
        Stack<Character> stack = new Stack<>();
        StringBuilder strB = new StringBuilder();
        for (int i = 0; i < S.length(); i++) {
            if (S.charAt(i) == '(') {
                // 如果栈为空，则说明要放 外( 则不放入解集
                if (!stack.empty()) {
                    strB.append('(');
                }
                stack.push('(');
            }
            if (S.charAt(i) == ')') {
                // 如果栈为1，则说明要放 外) 则不放入解集
                if (stack.size() != 1) {
                    strB.append(')');
                }
                stack.pop();
            }
        }
        return strB.toString();
    }
}
```

