## LeetCode-887-鸡蛋掉落

### 1. 题目：

鸡蛋掉落

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N`  共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次*移动*，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。

你的目标是**确切地**知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

 **示例 1：**

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

**示例 2：**

```
输入：K = 2, N = 6
输出：3
```

**示例 3：**

```
输入：K = 3, N = 14
输出：4
```

**提示：**

1. `1 <= K <= 100`
2. `1 <= N <= 10000`

### 2. 解题：

​		首先要避免一个误区，直接使用**二分法**，此时会发现根本没有使用题目中的`K`（鸡蛋个数）.这种做法是错误的。

​		我们要明白题目要求，这里鸡蛋数一定是有用的。例如，当我们有`1`个鸡蛋，`10`层楼时，那么我们只能从第一层开始，一层层开始丢鸡蛋，最糟糕的次数是`10`次（当`F=10`）；我们有`2`个鸡蛋时，还是`10`层楼，我们可以先进行二分法，在第`6`层丢鸡蛋，如果碎了，则在`1`到`5`层开始使用第二个鸡蛋一层一层试，因此最糟糕的次数为`6`次（`F=5`）。

​		上述说明只是为了证明鸡蛋数目是有用的，换句说鸡蛋数目越多给我们更多的操作空间。

​		接下来我们介绍解题思路：

​		题目要求我们使用`K`个鸡蛋，在`N`层高的楼中，找到`F`层的最少次数，也就是满足最糟糕条件的最少次数。我们设`f(k, n)`为在`K`个鸡蛋下，进行`n`步可以测量的最多楼层数，因此只要满足`f(k, n) >= N`，`n`就是要求的结果。

​		状态转移方程：

​		我们一共有`K`个鸡蛋，可以行动`n`次。来到`X`层，扔下鸡蛋，此时有两种情况：

- 鸡蛋碎了，鸡蛋少了一个，行动次数减少一次；往下可以测 f(k-1, n-1)层

- 鸡蛋没碎，鸡蛋不减，行动次数减少一次；往上可以测`f(k, n-1)`层

​        但是我们的状态转移方程并不是 `f(k,n)= max(f(k-1, n-1), f(k, n-1)) +1`，而是`f(k,n) = f(k-1,n-1) + f(k, n-1) + 1`（`+1`即测试的X层本身）

​		为什么是`+`而不是取`max`，`max`是`f`表示`K`个鸡蛋测`N`层楼**最坏情况**下需要移动多少次， 与之相对的`+`的`f`就表示应该用`k`个鸡蛋移动`n`次数**最好情况**下能测多少层。

​		假设你拥有`k`个鸡蛋`n`移动次数，直接来到`f(k-1, n-1)+1`层（注意这里的`f`表示的是楼层数量），事实上这一层就是我们选取的`X`。扔下鸡蛋最好的情况是什么？下楼是已知的不必再测，最好就是鸡蛋没碎，往上还能测`f(k, n-1))`层。

​		这有点绕，转换一下，我们有`k`个鸡蛋，要测的楼有  `f(k,n)= max(f(k-1, n-1), f(k, n-1)) +1`层。你来到`X`层（即`f(k-1, n-1)+1`层），扔下鸡蛋。不管鸡蛋碎没碎，你测出`F`最多还需要多少步呢？鸡蛋碎了往下还需要`n-1` 步，鸡蛋没碎往上也是需要`n-1`步。

​		所以在有`k`个鸡蛋的情况下测`f(k,n)= max(f(k-1, n-1), f(k, n-1)) +1`层楼**最多**需要`n`步。

​		边界条件：

- 只有一个鸡蛋`K=1`时，能移动多少次就能测多少楼。

- 只能移动一次`n=1`时，不管多少鸡蛋都只能测一层楼。

### 代码：

```java
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K+1][N+1];
        
        for (int n = 1; n <= N; n++) {
            for (int k = 1; k <= K; k++) {
                dp[k][n] = dp[k][n-1] + dp[k-1][n-1] + 1;
                if (dp[k][n] >= N) {
                    return n;
                }
            }
        }
        return N;
    }
}
```

